/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 public/models/64f1a714fe61576b46f27ca2.glb -o src/components/Avatar.jsx -k -r public
*/

import { useAnimations, useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { useEffect, useRef, useState } from "react";

import { useControls } from "leva";
import * as THREE from "three";
import { VISEMES } from "wawa-lipsync";
import { lipsyncManager } from "../App";

let setupMode = false;

export function Avatar(props) {
  const gltf = useGLTF("/models/wawalipavatar.glb");
  const { nodes, materials, scene } = gltf;
  
  // Debug: Log the loaded model structure
  useEffect(() => {
    console.log("=== WAWALIPAVATAR.GLB DEBUG ===");
    console.log("Full GLTF:", gltf);
    console.log("Scene:", scene);
    console.log("Nodes:", nodes);
    console.log("Materials:", materials);
    console.log("Scene children:", scene?.children);
    
    // Log all objects in the scene
    if (scene) {
      scene.traverse((child) => {
        console.log(`- ${child.name} (${child.type})`, child);
      });
    }
  }, [gltf, scene, nodes, materials]);

  // Try to load animations, but handle gracefully if they don't exist or are incompatible
  const animationsGLTF = useGLTF("/models/animations.glb");
  
  const group = useRef();
  
  // Check if the loaded avatar has its own animations
  const availableAnimations = scene.animations && scene.animations.length > 0 
    ? scene.animations 
    : (animationsGLTF.animations || []);
    
  const { actions, mixer } = useAnimations(availableAnimations, group);
  const [animation, setAnimation] = useState(() => {
    if (availableAnimations.length === 0) return null;
    // Look for "idle talk" first, then "Idle", then first available animation
    return availableAnimations.find((a) => a.name === "idle talk") 
      ? "idle talk" 
      : availableAnimations.find((a) => a.name === "Idle") 
      ? "Idle" 
      : availableAnimations[0]?.name || null;
  });

  const { smoothMovements, responsiveness, selectedAnimation } = useControls("Avatar", {
    smoothMovements: {
      value: false, // Changed to false for snappier default
      label: "Smooth Movements",
    },
    responsiveness: {
      value: 0.8,
      min: 0.1,
      max: 1.0,
      step: 0.1,
      label: "Animation Speed",
    },
    selectedAnimation: {
      value: animation || "None",
      options: availableAnimations.length > 0 
        ? availableAnimations.reduce((acc, anim) => {
            acc[anim.name] = anim.name;
            return acc;
          }, {})
        : { "None": "None" },
      label: "Animation",
    },
  });

  // Debug: Log available animations
  useEffect(() => {
    console.log("Available animations:", availableAnimations.map(a => a.name));
    console.log("Avatar scene structure:", scene);
  }, [availableAnimations, scene]);

  // Handle animation changes from the control panel
  useEffect(() => {
    if (selectedAnimation && selectedAnimation !== animation) {
      setAnimation(selectedAnimation);
    }
  }, [selectedAnimation]);
  
  useEffect(() => {
    if (animation && actions[animation]) {
      // Simple animation playback like it was working before
      try {
        // Stop all other animations first  
        Object.keys(actions).forEach(actionName => {
          if (actionName !== animation && actions[actionName]) {
            actions[actionName].stop();
          }
        });
        
        // Play the selected animation normally (like before)
        actions[animation]
          ?.reset()
          .fadeIn(mixer.stats.actions.inUse === 0 ? 0 : 0.5)
          .play();
          
        return () => actions[animation]?.fadeOut(0.5);
      } catch (error) {
        console.warn(`Animation ${animation} failed to play:`, error);
      }
    }
  }, [animation, actions]);

  // Cache morph target mappings for better performance
  const morphTargetCache = useRef({});
  
  const lerpMorphTarget = (target, value, speed = 0.3) => {
    scene.traverse((child) => {
      if (child.isSkinnedMesh && child.morphTargetDictionary) {
        const cacheKey = `${child.name}-${target}`;
        
        // Check cache first
        if (morphTargetCache.current[cacheKey] !== undefined) {
          const index = morphTargetCache.current[cacheKey];
          if (index !== -1 && child.morphTargetInfluences[index] !== undefined) {
            child.morphTargetInfluences[index] = THREE.MathUtils.lerp(
              child.morphTargetInfluences[index],
              value,
              speed
            );
          }
          return;
        }
        
        let targetIndex = child.morphTargetDictionary[target];
        
        if (targetIndex === undefined) {
          // Try alternatives only once and cache the result
          const alternatives = {
            'aa': ['mouthOpen', 'jawOpen', 'mouth_open', 'jaw_open'],
            'E': ['mouthSmile', 'mouth_smile', 'mouthLeft', 'mouth_left'],
            'I': ['mouthClose', 'mouth_close', 'mouthRight', 'mouth_right'],
            'O': ['mouthFunnel', 'mouth_funnel', 'mouthPucker', 'mouth_pucker'],
            'U': ['mouthPucker', 'mouth_pucker', 'mouthFunnel', 'mouth_funnel']
          };
          
          if (alternatives[target]) {
            for (const alt of alternatives[target]) {
              const altIndex = child.morphTargetDictionary[alt];
              if (altIndex !== undefined && child.morphTargetInfluences[altIndex] !== undefined) {
                targetIndex = altIndex;
                break;
              }
            }
          }
        }
        
        // Cache the result (even if -1 for not found)
        morphTargetCache.current[cacheKey] = targetIndex || -1;
        
        if (targetIndex !== undefined && child.morphTargetInfluences[targetIndex] !== undefined) {
          child.morphTargetInfluences[targetIndex] = THREE.MathUtils.lerp(
            child.morphTargetInfluences[targetIndex],
            value,
            speed
          );

          if (!setupMode) {
            try {
              set({
                [target]: value,
              });
            } catch (e) {}
          }
        }
      }
    });
  };

  const [blink, setBlink] = useState(false);
  const [winkLeft, setWinkLeft] = useState(false);
  const [winkRight, setWinkRight] = useState(false);

  useFrame(() => {
    // Eye blinking
    lerpMorphTarget("eyeBlinkLeft", blink || winkLeft ? 1 : 0, 0.5);
    lerpMorphTarget("eyeBlinkRight", blink || winkRight ? 1 : 0, 0.5);

    // LIPSYNC - exactly like it was working before
    if (setupMode) {
      return;
    }

    const viseme = lipsyncManager.viseme;
    const state = lipsyncManager.state;
    const features = lipsyncManager.features;
    
    // Debug: Log when we have audio activity
    if (features && features.volume > 0.01) {
      console.log('Avatar useFrame - Volume:', features.volume.toFixed(3), 'Viseme:', viseme, 'State:', state);
    }
    
    // Use the responsiveness slider for animation speed - optimized for TTS
    const baseSpeed = responsiveness;
    // Much faster speeds for TTS audio sync
    const activeSpeed = smoothMovements ? (state === "vowel" ? baseSpeed * 1.2 : baseSpeed * 1.5) : baseSpeed * 2.0;
    const deactiveSpeed = smoothMovements ? (state === "vowel" ? baseSpeed * 1.0 : baseSpeed * 1.2) : baseSpeed * 1.8;
    
    lerpMorphTarget(viseme, 1, activeSpeed);

    Object.values(VISEMES).forEach((value) => {
      if (viseme === value) {
        return;
      }
      lerpMorphTarget(value, 0, deactiveSpeed);
    });
  });

  useEffect(() => {
    let blinkTimeout;
    const nextBlink = () => {
      blinkTimeout = setTimeout(() => {
        setBlink(true);
        setTimeout(() => {
          setBlink(false);
          nextBlink();
        }, 200);
      }, THREE.MathUtils.randInt(1000, 5000));
    };
    nextBlink();
    return () => clearTimeout(blinkTimeout);
  }, []);

  // Function to safely render mesh if it exists
  const renderMesh = (nodeName, materialName, withMorphTargets = false) => {
    const node = nodes[nodeName];
    const material = materials[materialName];
    
    if (!node || !node.geometry || !material) {
      return null;
    }

    const meshProps = {
      name: nodeName,
      geometry: node.geometry,
      material: material,
      skeleton: node.skeleton,
    };

    if (withMorphTargets && node.morphTargetDictionary && node.morphTargetInfluences) {
      meshProps.morphTargetDictionary = node.morphTargetDictionary;
      meshProps.morphTargetInfluences = node.morphTargetInfluences;
    }

    return <skinnedMesh key={nodeName} {...meshProps} />;
  };

  return (
    <group {...props} dispose={null} ref={group}>
      {scene ? (
        // Just render the entire scene as-is for now
        <primitive object={scene} />
      ) : (
        // Fallback: render a simple cube to show something is there
        <mesh>
          <boxGeometry args={[1, 1, 1]} />
          <meshStandardMaterial color="red" />
        </mesh>
      )}
    </group>
  );
}

useGLTF.preload("/models/wawalipavatar.glb");
// Preload animations but don't fail if they don't exist
try {
  useGLTF.preload("/models/animations.glb");
} catch (error) {
  console.warn("Could not preload animations.glb:", error);
}
